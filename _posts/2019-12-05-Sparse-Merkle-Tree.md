---
layout: post
title: "稀疏默克尔树（Sparse Merkle Tree）"
subtitle: "Sparse Merkle Tree"
date: 2019-12-05 10:24:00
author: "hello2mao"
tags:
  - algorithm
---

<!-- TOC -->

- [1. 默克尔树](#1-默克尔树)
  - [1.1. 默克尔树的存在证明](#11-默克尔树的存在证明)
  - [1.2. 默克尔树的不存在证明](#12-默克尔树的不存在证明)
- [2. 稀疏默克尔树](#2-稀疏默克尔树)
  - [2.1. 稀疏默克尔树的存在证明](#21-稀疏默克尔树的存在证明)
  - [2.2. 稀疏默克尔树的不存在证明](#22-稀疏默克尔树的不存在证明)
- [3. Ref](#3-ref)

<!-- /TOC -->

# 1. 默克尔树

Merkle 树的叶子是数据块的 hash 值。非叶节点是其对应子节点串联字符串的 hash。

如下图所示，`A`、`B`、`C`、`D`是数据块，`H()`代表哈希函数。

![](/img/posts/merkle-tree.png)

## 1.1. 默克尔树的存在证明

默克尔树的存在证明，也叫做默克尔证明，这些证明能够表明一个叶节点是默克尔树的一部分。

例如，为了证明数据`A`（严格来说是`A`的哈希`H(A)`）存在于此默克尔树中，只需要给出`H(B)`和`H(H(C)+H(D))`，就可以计算出根哈希，然后和原根哈希一比较即可。

![](/img/posts/merkle-proof.png)

## 1.2. 默克尔树的不存在证明

不太容易实现。

# 2. 稀疏默克尔树

稀疏默克尔树（Sparse Merkle Tree，SMT）与默克尔树基本类似，只是数据是有序的。

例如有一个四个叶子节点的SMT，然后有数据`A`和`D`，那么这SMT如下：

![](/img/posts/smt-sample-1.png)

可以看到，`A`和`D`被有序的放到了索引是0和3的位置，而所以是1和2的位置是`null`。



## 2.1. 稀疏默克尔树的存在证明

与默克尔树的存在证明一致，只需要给出`H(null)`和`H(H(null)+H(D))`。

且SMT的值可以在O(log(n)) 时间内进行更新、插入或删除操作。

## 2.2. 稀疏默克尔树的不存在证明

与默克尔树最大的区别在于，稀疏默克尔树可以方便的实现不存在证明。

例如需要证明`C`不存在，那么只需证明索引3处是`null`即可，也就转化为常规的默克尔证明，只需给出`H(H(A)+H(null))`和`H(D)`，如下图所示：

![](/img/posts/smt-sample-2.png)

# 3. Ref

- [What’s a Sparse Merkle Tree?](https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837)


