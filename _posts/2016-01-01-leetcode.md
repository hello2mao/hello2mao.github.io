---
layout: post
title: "leetcode"
subtitle: "leetcode"
date: 2016-01-01 15:00:00
author: "hello2mao"
hidden: true
tags:
  - algorithm
---


<!-- TOC -->

- [1. Ref](#1-ref)
- [2. Progress](#2-progress)
- [3. String（字符串）](#3-string%e5%ad%97%e7%ac%a6%e4%b8%b2)
  - [3.1. 基础](#31-%e5%9f%ba%e7%a1%80)
  - [3.2. 举例](#32-%e4%b8%be%e4%be%8b)
    - [3.2.1. 基础](#321-%e5%9f%ba%e7%a1%80)
    - [3.2.2. 提高](#322-%e6%8f%90%e9%ab%98)
    - [3.2.3. Substring](#323-substring)
    - [3.2.4. Palindrome](#324-palindrome)
    - [3.2.5. Parentheses](#325-parentheses)
    - [3.2.6. Subsequence](#326-subsequence)
- [4. Array（数组）](#4-array%e6%95%b0%e7%bb%84)
  - [4.1. 基础](#41-%e5%9f%ba%e7%a1%80)
    - [4.1.1. 排序算法](#411-%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95)
  - [4.2. 举例](#42-%e4%b8%be%e4%be%8b)
    - [4.2.1. 基础](#421-%e5%9f%ba%e7%a1%80)
    - [4.2.2. 提高](#422-%e6%8f%90%e9%ab%98)
    - [4.2.3. Interval](#423-interval)
    - [4.2.4. Counter](#424-counter)
    - [4.2.5. Sort](#425-sort)
- [5. Math（数学）](#5-math%e6%95%b0%e5%ad%a6)
  - [5.1. 举例](#51-%e4%b8%be%e4%be%8b)
    - [5.1.1. 基础](#511-%e5%9f%ba%e7%a1%80)
    - [5.1.2. Sum](#512-sum)
    - [5.1.3. 很少考](#513-%e5%be%88%e5%b0%91%e8%80%83)
- [6. Tree（树）](#6-tree%e6%a0%91)
  - [6.1. 概念](#61-%e6%a6%82%e5%bf%b5)
    - [6.1.1. 术语](#611-%e6%9c%af%e8%af%ad)
    - [6.1.2. Binary Search Tree (BST)](#612-binary-search-tree-bst)
    - [6.1.3. Balanced Binary Tree (AVL)](#613-balanced-binary-tree-avl)
    - [6.1.4. Tree Traversal](#614-tree-traversal)
  - [6.2. 举例](#62-%e4%b8%be%e4%be%8b)
    - [6.2.1. 基础](#621-%e5%9f%ba%e7%a1%80)
    - [6.2.2. Preorder](#622-preorder)
    - [6.2.3. Postorder](#623-postorder)
    - [6.2.4. BFS](#624-bfs)
    - [6.2.5. BST](#625-bst)
    - [6.2.6. 重要程度](#626-%e9%87%8d%e8%a6%81%e7%a8%8b%e5%ba%a6)
- [7. Backtracking（回溯）](#7-backtracking%e5%9b%9e%e6%ba%af)
  - [7.1. 基本概念](#71-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
  - [7.2. 举例](#72-%e4%b8%be%e4%be%8b)
    - [7.2.1. 基础](#721-%e5%9f%ba%e7%a1%80)
    - [7.2.2. Enumeration](#722-enumeration)
  - [7.3. Ref](#73-ref)

<!-- /TOC -->

# 1. Ref

- [Leetcode 分类顺序表](https://cspiration.com/leetcodeClassification)
- [azl397985856/leetcode](https://github.com/azl397985856/leetcode)
- [MisterBooo/LeetCodeAnimation](https://github.com/MisterBooo/LeetCodeAnimation)
- 常用知识点: https://www.cnblogs.com/BigJunOba/p/9508688.html
- [数据结构和算法必知必会的 50 个代码实现](https://github.com/wangzheng0822/algo)

# 2. Progress

![leetcode](https://leetcode-badge.chyroc.cn/?name=hello2mao)

# 3. String（字符串）
## 3.1. 基础
## 3.2. 举例

### 3.2.1. 基础

- [x] [28 Implement strStr()](/snippet/java/leetcode/28.implement-str-str.java)
- [x] [14 Longest Common Prefix](/snippet/java/leetcode/14.longest-common-prefix.java)
- [x] [58 Length of Last Word](/snippet/java/leetcode/58.length-of-last-word.java)
- [x] [387 First Unique Character in a String](/snippet/java/leetcode/387.first-unique-character-in-a-string.java)
- [ ] 383 Ransom Note
- [ ] 344 Reverse String
- [ ] 151 Reverse Words in a String
- [ ] 186 Reverse Words in a String II
- [ ] 345 Reverse Vowels of a String
- [ ] 205 Isomorphic Strings
- [ ] 293 Flip Game
- [ ] 294 Flip Game II
- [ ] 290 Word Pattern
- [ ] 242 Valid Anagram
- [ ] 49 Group Anagrams
- [ ] 249 Group Shifted Strings
- [ ] 87 Scramble String
- [ ] 179 Largest Number 很少考
- [ ] 6 ZigZag Conversion 很少考
- [ ] 161 One Edit Distance
- [ ] 38 Count and Say
- [ ] 358 Rearrange String k Distance Apart
- [ ] 316 Remove Duplicate Letters
- [ ] 271 Encode and Decode Strings
- [ ] 168 Excel Sheet Column Title
- [ ] 171 Excel Sheet Column Number
- [ ] 13 Roman to Integer
- [ ] 12 Integer to Roman
- [ ] 273 Integer to English Words
- [ ] 246 Strobogrammatic Number
- [ ] 247 Strobogrammatic Number II
- [ ] 248 Strobogrammatic Number III 很少考

### 3.2.2. 提高

- [ ] 68 Text Justification
- [ ] 65 Valid Number
- [ ] 157 Read N Characters Given Read4
- [ ] 158 Read N Characters Given Read4 II - Call multiple times

### 3.2.3. Substring

- [ ] 76 Minimum Window Substring Sliding Window
- [ ] 30 Substring with Concatenation of All Words Sliding Window
- [ ] 3 Longest Substring Without Repeating Characters Sliding Window
- [ ] 340 Longest Substring with At Most K Distinct Characters Sliding Window
- [ ] 395 Longest Substring with At Least K Repeating Characters Sliding Window
- [ ] 159 Longest Substring with At Most Two Distinct Characters Sliding Window

### 3.2.4. Palindrome

- [ ] 125 Valid Palindrome
- [ ] 266 Palindrome Permutation
- [ ] 5 Longest Palindromic Substring
- [ ] 9 Palindrome Number
- [ ] 214 Shortest Palindrome
- [ ] 336 Palindrome Pairs
- [ ] 131 Palindrome Partitioning
- [ ] 132 Palindrome Partitioning II
- [ ] 267 Palindrome Permutation II

### 3.2.5. Parentheses

- [ ] 20 Valid Parentheses
- [ ] 22 Generate Parentheses
- [ ] 32 Longest Valid Parentheses
- [ ] 241 Different Ways to Add Parentheses
- [ ] 301 Remove Invalid Parentheses

### 3.2.6. Subsequence

- [ ] 392 Is Subsequence
- [ ] 115 Distinct Subsequences
- [ ] 187 Repeated DNA Sequences 很少考

# 4. Array（数组）
## 4.1. 基础

### 4.1.1. 排序算法

| 名称         |   最优   |      平均      |     最坏     |  内存  | 稳定  | 备注                |
| ------------ | :------: | :------------: | :----------: | :----: | :---: | ------------------- |
| **冒泡排序** |    n     |      n^2       |     n^2      |   1    |  Yes  |                     |
| **插入排序** |    n     |      n^2       |     n^2      |   1    |  Yes  |                     |
| **选择排序** |   n^2    |      n^2       |     n^2      |   1    |  No   |                     |
| **堆排序**   | n log(n) |    n log(n)    |   n log(n)   |   1    |  No   |                     |
| **归并排序** | n log(n) |    n log(n)    |   n log(n)   |   n    |  Yes  |                     |
| **快速排序** | n log(n) |    n log(n)    |     n^2      | log(n) |  No   |                     |
| **希尔排序** | n log(n) | 取决于差距序列 | n (log(n))^2 |   1    |  No   |                     |
| **计数排序** |  n + r   |     n + r      |    n + r     | n + r  |  Yes  | r - 数组里最大的数  |
| **基数排序** |  n \* k  |     n \* k     |    n \* k    | n + k  |  Yes  | k - 最长 key 的升序 |

## 4.2. 举例

### 4.2.1. 基础

- [x] [27 Remove Element](/snippet/java/leetcode/27.remove-element.java)
- [x] [26 Remove Duplicates from Sorted Array](/snippet/java/leetcode/26.remove-duplicates-from-sorted-array.java)
- [x] [80 Remove Duplicates from Sorted Array II](/snippet/java/leetcode/80.remove-duplicates-from-sorted-array-ii.java)
- [x] [189 Rotate Array](/snippet/java/leetcode/189.rotate-array.java)
- [x] [41 First Missing Positive](/snippet/java/leetcode/41.first-missing-positive.java)
- [x] [299 Bulls and Cows](/snippet/java/leetcode/299.bulls-and-cows.java)
- [x] [134 Gas Station](/snippet/java/leetcode/134.gas-station.java)
- [ ] 118 Pascal's Triangle 很少考
- [ ] 119 Pascal's Triangle II 很少考
- [ ] 169 Majority Element 很少考
- [ ] 229 Majority Element II 很少考
- [x] [274 H-Index](/snippet/java/leetcode/274.h-index.java)
- [ ] 275 H-Index II Binary Search
- [ ] 243 Shortest Word Distance
- [ ] 244 Shortest Word Distance II
- [ ] 245 Shortest Word Distance III
- [x] [217 Contains Duplicate](/snippet/java/leetcode/217.contains-duplicate.java)
- [ ] 219 Contains Duplicate II 很少考
- [ ] 220 Contains Duplicate III 很少考
- [x] [55 Jump Game](/snippet/java/leetcode/55.jump-game.java)
- [x] [45 Jump Game II](/snippet/java/leetcode/45.jump-game-ii.java)
- [x] [121 Best Time to Buy and Sell Stock](/snippet/java/leetcode/121.best-time-to-buy-and-sell-stock.java)
- [ ] 122 Best Time to Buy and Sell Stock II
- [ ] 123 Best Time to Buy and Sell Stock III
- [ ] 188 Best Time to Buy and Sell Stock IV
- [ ] 309 Best Time to Buy and Sell Stock with Cooldown
- [ ] 11 Container With Most Water
- [ ] 42 Trapping Rain Water
- [ ] 334 Increasing Triplet Subsequence
- [ ] 128 Longest Consecutive Sequence
- [ ] 164 Maximum Gap Bucket
- [ ] 287 Find the Duplicate Number
- [ ] 135 Candy 很少考
- [ ] 330 Patching Array 很少考

### 4.2.2. 提高

- [ ] 4 Median of Two Sorted Arrays
- [ ] 321 Create Maximum Number 很少考
- [ ] 327 Count of Range Sum 很少考
- [ ] 289 Game of Life

### 4.2.3. Interval

- [ ] 57 Insert Interval
- [ ] 56 Merge Intervals
- [ ] 252 Meeting Rooms
- [ ] 253 Meeting Rooms II
- [ ] 352 Data Stream as Disjoint Intervals TreeMap

### 4.2.4. Counter

- [ ] 239 Sliding Window Maximum
- [ ] 295 Find Median from Data Stream
- [ ] 53 Maximum Subarray
- [ ] 325 Maximum Size Subarray Sum Equals k
- [ ] 209 Minimum Size Subarray Sum
- [ ] 238 Product of Array Except Self
- [ ] 152 Maximum Product Subarray
- [ ] 228 Summary Ranges
- [ ] 163 Missing Ranges

### 4.2.5. Sort

- [ ] 88 Merge Sorted Array
- [ ] 75 Sort Colors
- [ ] 283 Move Zeroes
- [ ] 376 Wiggle Subsequence
- [ ] 280 Wiggle Sort
- [ ] 324 Wiggle Sort II

# 5. Math（数学）
## 5.1. 举例

### 5.1.1. 基础

- [ ] 7 Reverse Integer
- [ ] 165 Compare Version Numbers
- [ ] 66 Plus One
- [ ] 8 String to Integer (atoi)
- [ ] 258 Add Digits
- [ ] 67 Add Binary
- [ ] 43 Multiply Strings
- [ ] 29 Divide Two Integers
- [ ] 69 Sqrt(x)
- [ ] 50 Pow(x, n)
- [ ] 367 Valid Perfect Square
- [ ] 365 Water and Jug Problem
- [ ] 204 Count Primes

### 5.1.2. Sum

- [x] [1 Two Sum](/snippet/java/leetcode/1.two-sum.java)
- [ ] 167 Two Sum II - Input array is sorted
- [x] [15 3Sum](/snippet/java/leetcode/15.3-sum.java)
- [ ] 16 3Sum Closest 很少考
- [ ] 259 3Sum Smaller 很少考
- [x] [18 4Sum](/snippet/java/leetcode/18.4-sum.java)

### 5.1.3. 很少考

- [ ] 231 Power of Two
- [ ] 326 Power of Three
- [ ] 342 Power of Four
- [ ] 372 Super Pow
- [ ] 233 Number of Digit One
- [ ] 319 Bulb Switcher
- [ ] 292 Nim Game
- [ ] 202 Happy Number
- [ ] 400 Nth Digit
- [ ] 263 Ugly Number
- [ ] 264 Ugly Number II
- [ ] 306 Additive Number
- [ ] 172 Factorial Trailing Zeroes
- [ ] 343 Integer Break
- [ ] 396 Rotate Function
- [ ] 390 Elimination Game
- [ ] 386 Lexicographical Numbers
- [ ] 357 Count Numbers with Unique Digits
- [ ] 360 Sort Transformed Array
- [ ] 397 Integer Replacement
- [ ] 368 Largest Divisible Subset

# 6. Tree（树）
## 6.1. 概念

```java
 public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
     }
```

### 6.1.1. 术语

- **节点深度**：对任意节点 x，x 节点的深度表示为根节点到 x 节点的路径长度。所以根节点深度为 0，第二层节点深度为 1，以此类推
- **节点高度**：对任意节点 x，叶子节点到 x 节点的路径长度就是节点 x 的高度
- **树的深度**：一棵树中节点的最大深度就是树的深度，也称为高度
- **父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点
- **子节点**：一个节点含有的子树的根节点称为该节点的子节点
- **节点的层次**：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
- **兄弟节点**：拥有共同父节点的节点互称为兄弟节点
- **度**：节点的子树数目就是节点的度
- **叶子节点**：度为零的节点就是叶子节点
- **祖先**：对任意节点 x，从根节点到节点 x 的所有节点都是 x 的祖先（节点 x 也是自己的祖先）
- **后代**：对任意节点 x，从节点 x 到叶子节点的所有节点都是 x 的后代（节点 x 也是自己的后代）
- **森林**：m 颗互不相交的树构成的集合就是森林

### 6.1.2. Binary Search Tree (BST)

二叉搜索树、二叉查找树
vals of left-subtree < vals of right-subtree

```java
// Time Complexity: O(logn)
public TreeNode search(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) return root;
    if (key < root.val) {
        return search(root.left, root);
    } else {
        return search(root.right, root);
    }
}
```

### 6.1.3. Balanced Binary Tree (AVL)

平衡二叉树：左右子树的高度差<=1

### 6.1.4. Tree Traversal

- 广度优先（BFS）: Breadth First Traversal (Or Level Order Traversal)
- 深度优先（DFS）: Depth First Traversals
  - Preorder Traversal (Root-Left-Right)
  - **Inorder Traversal (Left-Root-Right)** // 对于 BST，结果是排序的，从小到大
  - Postorder Traversal (Left-Right-Root)

```txt
 ⁠    1
  ⁠  /  \
   ⁠2    3
  / ⁠\
 4 ⁠  5

BFS and DFSs of above Tree

Breadth First Traversal : 1 2 3 4 5

Depth First Traversals:
      Preorder Traversal : 1 2 4 5 3
      Inorder Traversal  :  4 2 5 1 3
      Postorder Traversal : 4 5 2 3 1
```

```java
    // 前序遍历 DFS
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null)
            return res;
        res.add(root.val);
        res.addAll(preorderTraversal(root.left));
        res.addAll(preorderTraversal(root.right));
        return res;
    }
```

```java
    // 中序遍历 DFS
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        res.addAll(inorderTraversal(root.left));
        res.add(root.val);
        res.addAll(inorderTraversal(root.right));
        return res;
    }
```

```java
    // 后序遍历 DFS
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null)
            return res;
        res.addAll(postorderTraversal(root.left));
        res.addAll(postorderTraversal(root.right));
        res.add(root.val);
        return res;
    }
```

```java
    // 层遍历 BFS
    public void levelorderTraversal(Node root) {
		Queue<Node> q = new LinkedList<Node>();
		if (root == null)
			return;
		q.offer(root);
		while (!q.isEmpty()) {
			Node n = (Node) q.poll();
			System.out.print(" " + n.data);
			if (n.left != null)
				q.add(n.left);
			if (n.right != null)
				q.add(n.right);
		}
	}
```

## 6.2. 举例

### 6.2.1. 基础

- [x] [144 Binary Tree Preorder Traversal preorder](/snippet/java/leetcode/144.binary-tree-preorder-traversal.java)
- [x] [94 Binary Tree Inorder Traversal Inorder](/snippet/java/leetcode/94.binary-tree-inorder-traversal.java)
- [x] [145 Binary Tree Postorder Traversal postorder](/snippet/java/leetcode/145.binary-tree-postorder-traversal.java)
- [x] [102 Binary Tree Level Order Traversal](/snippet/java/leetcode/102.binary-tree-level-order-traversal.java)

### 6.2.2. Preorder

- [x] [100 Same Tree preorder](/snippet/java/leetcode/100.same-tree.java)
- [x] [101 Symmetric Tree preorder](/snippet/java/leetcode/101.symmetric-tree.java)
- [x] [226 Invert Binary Tree preorder + BFS](/snippet/java/leetcode/226.invert-binary-tree.java)
- [x] [257 Binary Tree Paths preorder](/snippet/java/leetcode/257.binary-tree-paths.java)
- [x] [112 Path Sum preorder](/snippet/java/leetcode/112.path-sum.java)
- [x] [113 Path Sum II preorder](/snippet/java/leetcode/113.path-sum-ii.java)
- [ ] 129 Sum Root to Leaf Numbers preorder
- [ ] 298 Binary Tree Longest Consecutive Sequence preorder
- [ ] 111 Minimum Depth of Binary Tree preorder

### 6.2.3. Postorder

- [x] [104 Maximum Depth of Binary Tree postorder](/snippet/java/leetcode/104.maximum-depth-of-binary-tree.java)
- [x] [110 Balanced Binary Tree postorder](/snippet/java/leetcode/110.balanced-binary-tree.java)
- [x] [124 Binary Tree Maximum Path Sum postorder](/snippet/java/leetcode/124.binary-tree-maximum-path-sum.java)
- [ ] locked 250 Count Univalue Subtrees postorder
- [ ] locked 366 Find Leaves of Binary Tree postorder

### 6.2.4. BFS

- [x] [107 Binary Tree Level Order Traversal II BFS](/snippet/java/leetcode/107.binary-tree-level-order-traversal-ii.java)
- [x] [103 Binary Tree Zigzag Level Order Traversal BFS](/snippet/java/leetcode/103.binary-tree-zigzag-level-order-traversal.java)
- [x] [199 Binary Tree Right Side View BFS + preorder](/snippet/java/leetcode/199.binary-tree-right-side-view.java)

### 6.2.5. BST

- [ ] 98 Validate Binary Search Tree preorder
- [ ] 235 Lowest Common Ancestor of a Binary Search Tree preorder
- [ ] 236 Lowest Common Ancestor of a Binary Tree postorder
- [ ] 108 Convert Sorted Array to Binary Search Tree binary search
- [ ] 109 Convert Sorted List to Binary Search Tree binary search
- [ ] 173 Binary Search Tree Iterator inorder
- [ ] 230 Kth Smallest Element in a BST inorder
- [ ] 297 Serialize and Deserialize Binary Tree BFS
- [ ] 285 Inorder Successor in BST inorder
- [ ] 270 Closest Binary Search Tree Value preorder
- [ ] 272 Closest Binary Search Tree Value II inorder
- [ ] 99 Recover Binary Search Tree inorder

### 6.2.6. 重要程度

- [ ] 156 Binary Tree Upside Down 很少考
- [ ] 114 Flatten Binary Tree to Linked List 很少考
- [ ] 255 Verify Preorder Sequence in Binary Search Tree 很少考
- [ ] 333 Largest BST Subtree 很少考
- [ ] 222 Count Complete Tree Nodes 很少考
- [ ] 105 Construct Binary Tree from Preorder and Inorder Traversal 很少考
- [ ] 106 Construct Binary Tree from Inorder and Postorder Traversal 很少考
- [ ] 116 Populating Next Right Pointers in Each Node 重要
- [ ] 117 Populating Next Right Pointers in Each Node II 重要
- [ ] 314 Binary Tree Vertical Order Traversal 重要
- [ ] 96 Unique Binary Search Trees 重要
- [ ] 95 Unique Binary Search Trees II 很少考
- [ ] 331 Verify Preorder Serialization of a Binary Tree 很少考

# 7. Backtracking（回溯）

## 7.1. 基本概念

- backtracking（回溯算法）也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。
- 回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。
- 回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。
- 算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。
  - 回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。
  - 而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。

这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。

## 7.2. 举例

### 7.2.1. 基础

- [x] [78 Subsets](/snippet/java/leetcode/78.subsets.java)
- [x] [90 Subsets II](/snippet/java/leetcode/90.subsets-ii.java)
- [x] [77 Combinations](/snippet/java/leetcode/77.combinations.java)
- [ ] 39 Combination Sum
- [ ] 40 Combination Sum II
- [ ] 216 Combination Sum III
- [ ] 377 Combination Sum IV Dynamic Programming
- [ ] 254 Factor Combinations
- [ ] 46 Permutations
- [ ] 47 Permutations II
- [ ] 31 Next Permutation String
- [ ] 60 Permutation Sequence String
- [ ] 291 Word Pattern II

### 7.2.2. Enumeration

- [ ] 17 Letter Combinations of a Phone Number
- [ ] 320 Generalized Abbreviation 要重录
- [ ] 93 Restore IP Addresses 很少考
- [ ] 282 Expression Add Operators
- [ ] 140 Word Break II
- [ ] 351 Android Unlock Patterns

## 7.3. Ref

https://blog.csdn.net/crystal6918/article/details/51924665
